# План реализации микросервиса email на Go

## Анализ текущего C# сервиса

### Протоколы подключения к email серверу

1. **SMTP (отправка писем):**
   - Используется библиотека **MailKit** (`MailKit.Net.Smtp`)
   - Подключение через `SecureSocketOptions.Auto` (автоматическое определение SSL/TLS)
   - Поддержка нескольких SMTP серверов (до 5, конфигурируются через INI)
   - Параметры подключения: Host, Port, User, Password, DisplayName
   - Используется DSN (Delivery Status Notification) для отслеживания доставки
   - Envelope ID формируется как `askemailsender{taskId}` для идентификации писем

2. **POP3 (получение статусов доставки):**
   - Используется `MailKit.Net.Pop3` для чтения DSN уведомлений
   - Подключение каждые 60 минут для проверки статусов
   - Парсинг DSN сообщений через `MessageDeliveryStatus`
   - Обработка статусов: delivered, failed, delayed, relayed, expanded

### Тестовый режим

- Включается через параметр `ModeDebug = True` в секции `[Mode]` INI файла
- При включении все письма перенаправляются на тестовый email
- Тестовый email получается из БД через процедуру `pcsystem.PKG_EMAIL.GET_TEST_EMAIL()`
- Логируется изменение адреса: `"DebugMode изменено: {original} -> {testEmail}"`
- Реализовано в `SmtpAdapter.DoSendEmail()` (строки 121-126)

### Архитектура сервиса

1. **Источник данных:** Oracle Advanced Queueing (AQ) - очередь `askaq.aq_ask`
2. **Обработка:** Асинхронная обработка XML сообщений из очереди
3. **Вложения:** Три типа вложений:
   - Тип 1: Генерация через Crystal Reports Web Service
   - Тип 2: Загрузка из CLOB (Base64) в БД
   - Тип 3: Загрузка готового PDF файла с файловой системы
4. **Результаты:** Сохранение статусов в БД через `pcsystem.pkg_email.save_email_response()`

## План реализации на Go

### 1. Структура проекта

```
email-service/
├── cmd/
│   └── email-service/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── database/
│   │   ├── oracle_connector.go
│   │   ├── queue_reader.go
│   │   ├── email_response.go
│   │   └── procedures.go
│   ├── email/
│   │   ├── smtp.go
│   │   ├── pop3.go
│   │   └── dsn.go
│   ├── parser/
│   │   └── xml.go
│   ├── logger/
│   │   └── logger.go
│   └── service/
│       └── email_service.go
├── pkg/
│   └── attachments/
│       ├── crystal.go
│       ├── clob.go
│       └── file.go
├── go.mod
├── go.sum
├── config.ini
└── README.md
```

### 2. Основные компоненты

#### 2.1 Конфигурация (`internal/config/config.go`)
- Парсинг INI файла (использовать `gopkg.in/ini.v1`)
- Структуры для SMTP конфигурации (массив до 5 серверов)
- Параметры Oracle, расписания, режимов работы
- Валидация конфигурации при старте

#### 2.2 Работа с Oracle (`internal/database/`)

**oracle_connector.go:**
- Структура `DBConnection` с методами `WithDB()` и `WithDBTx()` для безопасного доступа
- Использование `sync.RWMutex` для параллельного чтения
- Счетчик активных операций (`activeOps`) для предотвращения переподключения во время транзакций
- Периодическое переподключение каждые 30 минут (настраивается)
- Метод `waitForActiveOperations()` - ожидание завершения операций перед переподключением (до 35 секунд)
- Таймауты: `pingTimeout=5s`, `queryTimeout=30s`, `execTimeout=30s`, `connectionTimeout=10s`
- Настройки пула: `MaxOpenConns=200`, `MaxIdleConns=10`, `ConnMaxLifetime=5min`

**queue_reader.go:**
- Подписка на очередь `askaq.aq_ask` с consumer `SUB_EMAIL_SENDER`
- Метод `DequeueMany(count)` - извлечение батча сообщений
- Использование временных пакетов Oracle для работы с OUT-параметрами
- PL/SQL блоки для выполнения `DBMS_AQ.DEQUEUE` с `XMLSerialize`
- Обработка ошибок Oracle (код 25228 - очередь пуста)
- Поддержка контекста для graceful shutdown

**email_response.go:**
- Метод `SaveEmailResponse()` - вызов `pcsystem.pkg_email.save_email_response()`
- Использование транзакций через `WithDBTx()`
- Обработка OUT-параметров через временные пакеты Oracle
- Поддержка контекста для graceful shutdown

**procedures.go:**
- `GetTestEmail()` - получение тестового email через `pcsystem.PKG_EMAIL.GET_TEST_EMAIL()`
- `GetWebServiceUrl()` - адрес Crystal Reports через `pcsystem.PKG_EMAIL.GET_SOAP_ADDRESS()`
- `GetEmailReportClob()` - получение CLOB вложений через `pcsystem.pkg_email.get_email_report_clob()`
- Все процедуры используют `WithDBTx()` для безопасной работы с транзакциями

#### 2.3 Email клиенты (`internal/email/`)
- **smtp.go:** 
  - Использовать `github.com/go-mail/mail` или `github.com/emersion/go-smtp`
  - Поддержка TLS/SSL (автоопределение как в MailKit)
  - Реализация DSN через Envelope ID (`askemailsender{taskId}`)
  - Ограничение частоты отправки (MinSendIntervalMsec, MinSendEmailIntervalMsec)
  - Автоматическое переподключение при разрыве соединения
- **pop3.go:**
  - Использовать `github.com/emersion/go-pop3`
  - Периодическая проверка DSN (каждые 60 минут)
  - Парсинг статусов доставки
- **dsn.go:**
  - Парсинг DSN сообщений (RFC 3464)
  - Извлечение статусов: delivered, failed, delayed, relayed, expanded
  - Сопоставление Envelope ID с taskId

#### 2.4 Парсер XML (`internal/parser/xml.go`)
- Парсинг структуры сообщения из Oracle AQ
- Извлечение данных письма: taskId, smtpId, emailAddress, title, text, schedule
- Парсинг вложений (attach элементы)
- Обработка параметров вложений (attach_param)

#### 2.5 Обработка вложений (`pkg/attachments/`)
- **crystal.go:** Интеграция с Crystal Reports Web Service (SOAP)
- **clob.go:** Загрузка и декодирование Base64 из CLOB
- **file.go:** Чтение готовых файлов с диска

#### 2.6 Логирование (`internal/logger/logger.go`)
- Использование `go.uber.org/zap` для структурированного логирования
- Ротация логов через `gopkg.in/natefinch/lumberjack.v2`:
  - `MaxSize=100MB` - максимальный размер файла перед ротацией
  - `MaxBackups` - количество архивных файлов (из конфига)
  - `MaxAge=10` дней - хранение логов
  - `Compress=true` - сжатие архивных файлов
- Уровни логирования: Panic(0), Fatal(1), Error(2), Warn(3), Info(4), Debug(5)
- Двойной вывод: в файл (JSON) и консоль (читаемый формат)
- Структурированные логи с полями: `zap.Int64("taskID", ...)`, `zap.String("messageID", ...)`
- Поддержка `zap.AddCaller()` и `zap.AddStacktrace()` для ошибок

#### 2.7 Основной сервис (`internal/service/email_service.go`)
- Главный цикл обработки (аналог `jobLoop()`)
- Очередь сообщений (in-memory map по taskId)
- Очередь результатов для записи в БД
- Обработка расписания отправки (TimeStart - TimeEnd)
- Ограничение частоты отправки на email адрес
- Автоматический рестарт при критических ошибках
- **Graceful shutdown:**
  - Обработка сигналов `os.Interrupt`, `syscall.SIGTERM`, `syscall.SIGINT`
  - Единый таймаут shutdown (10 секунд по умолчанию)
  - Использование `context.WithTimeout()` для завершения операций
  - `sync.WaitGroup` для отслеживания всех горутин обработки
  - Обработка уже вычитанных сообщений даже при shutdown (критически важно!)
  - Использование `shutdownCtx` для завершения критических операций (отправка и сохранение в БД)
  - При отмене контекста - попытка сохранения через `context.Background()` для критических операций

### 3. Особенности реализации

#### 3.1 Тестовый режим
- При `ModeDebug = true`:
  - Вызов `pcsystem.PKG_EMAIL.GET_TEST_EMAIL()` при каждой отправке
  - Замена адреса получателя на тестовый
  - Логирование замены адреса с использованием `zap.String("original", ...)`, `zap.String("test", ...)`

#### 3.2 Обработка ошибок
- Подсчет критических ошибок (ORA-25263, SMTP "4.3.2 Please try again later")
- Автоматический рестарт при превышении MaxErrorCountForAutoRestart
- Graceful shutdown с завершением текущих операций
- **Важно:** Сообщения уже вычитаны из очереди (REMOVE), поэтому ОБЯЗАНЫ быть обработаны до конца
- При отмене контекста - сохранение статуса через `context.Background()` для предотвращения потери данных

#### 3.3 Производительность
- Пакетная обработка (portion = 20 сообщений за цикл)
- Параллельная обработка вложений где возможно
- Неблокирующие операции с очередями
- Использование `RWMutex` для параллельного чтения из БД
- Батчинг операций записи в БД (до 10000 за цикл)

#### 3.4 Безопасность работы с БД
- **Методы-обертки для безопасного доступа:**
  - `WithDB(func(*sql.DB) error)` - для операций без транзакций (использует `RLock()`)
  - `WithDBTx(ctx, func(*sql.Tx) error)` - для транзакций (использует `Lock()`, управляет счетчиком активных операций)
- **Счетчик активных операций:**
  - `BeginOperation()` - увеличивает счетчик перед операцией
  - `EndOperation()` - уменьшает счетчик после операции
  - `Reconnect()` ждет завершения операций (до 35 секунд) перед переподключением
- **Периодическое переподключение:**
  - Каждые 30 минут (настраивается)
  - Проверка активных операций перед переподключением
  - Логирование предупреждений при переподключении с активными операциями

### 4. Зависимости Go

```go
require (
    github.com/godror/godror v0.40.0          // Oracle driver
    github.com/go-mail/mail v2.3.1            // SMTP client
    github.com/emersion/go-pop3 v0.2.0        // POP3 client
    github.com/emersion/go-message v0.17.0    // Email parsing
    gopkg.in/ini.v1 v1.67.0                   // INI parser
    go.uber.org/zap v1.26.0                   // Structured logging (как в smsSender)
    gopkg.in/natefinch/lumberjack.v2 v2.2.1   // Log rotation
)
```

### 5. Конфигурационный файл (config.ini)

Структура аналогична текущему `email_sender.ini`:
- Секция `[ORACLE]` - подключение к БД
- Секции `[SMTP]`, `[SMTP1]` ... `[SMTP4]` - настройки SMTP серверов
- Секция `[Mode]` - режимы работы (Debug, SendHiddenCopyToSelf, IsBodyHTML)
- Секция `[Schedule]` - временные рамки отправки
- Секция `[Log]` - настройки логирования

### 6. Этапы реализации

1. **Этап 1:** Базовая структура проекта, конфигурация, логирование
2. **Этап 2:** Подключение к Oracle и работа с AQ очередью
3. **Этап 3:** Парсинг XML сообщений и создание структур данных
4. **Этап 4:** Реализация SMTP клиента с DSN поддержкой
5. **Этап 5:** Обработка вложений (все три типа)
6. **Этап 6:** POP3 клиент для получения статусов доставки
7. **Этап 7:** Основной цикл обработки и интеграция компонентов
8. **Этап 8:** Тестовый режим и обработка ошибок
9. **Этап 9:** Тестирование и оптимизация

### 7. Ключевые отличия от C# версии

- Использование goroutines для параллельной обработки
- Context для управления жизненным циклом операций
- Каналы (channels) для синхронизации вместо locks где возможно
- Стандартная библиотека `context` для таймаутов и отмены операций
- Структурированное логирование через zap (аналогично smsSender)
- Безопасная работа с БД через методы-обертки `WithDB()` и `WithDBTx()`
- Счетчик активных операций для предотвращения переподключения во время транзакций
- Graceful shutdown с обработкой уже вычитанных сообщений

### 8. Паттерны из проекта smsSender

#### 8.1 Структура проекта
- Разделение по функциональности: `db/`, `email/`, `logger/`, `service/`
- Использование `internal/` для приватных модулей
- Использование `cmd/` для точки входа приложения

#### 8.2 Стиль кодинга
- Структурированное логирование с контекстом: `logger.Log.Info("message", zap.String("key", value))`
- Использование интерфейсов и callback'ов для гибкости
- Обработка ошибок с проверкой контекста: `if ctx.Err() == context.Canceled`
- Комментарии на русском языке для документации
- Использование `defer` для гарантированного освобождения ресурсов

#### 8.3 Работа с транзакциями
- Все операции записи в БД выполняются через транзакции
- Использование временных пакетов Oracle для работы с OUT-параметрами
- PL/SQL блоки для вызова процедур с сохранением результатов в пакетные переменные
- Чтение результатов через функции-геттеры пакетов: `SELECT temp_pkg.get_result() FROM DUAL`

#### 8.4 Graceful shutdown
- Единый таймаут shutdown для всего приложения
- Использование `shutdownCtx` с таймаутом для завершения операций
- Обработка уже вычитанных сообщений даже при shutdown (критически важно!)
- Использование `sync.WaitGroup` для отслеживания всех горутин
- При отмене контекста - попытка сохранения через `context.Background()` для критических операций

#### 8.5 Работа с очередью Oracle AQ
- Использование `DequeueMany()` для батчевого чтения сообщений
- Первое сообщение читается с полным timeout, последующие - с минимальным (50ms)
- Проверка контекста перед каждой итерацией чтения
- При graceful shutdown - обработка уже вычитанных сообщений перед выходом
- Использование временных пакетов Oracle для работы с `DBMS_AQ.DEQUEUE`

#### 8.6 Обработка сообщений
- Батчевая обработка сообщений (по 10-100 штук)
- Параллельная обработка батчей через goroutines
- Использование `sync.WaitGroup` для синхронизации обработки батчей
- При ошибке обработки - сохранение статуса ошибки в БД
- При graceful shutdown - завершение обработки текущих батчей с использованием `shutdownCtx`

