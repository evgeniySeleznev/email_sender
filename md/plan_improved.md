# План реализации микросервиса email на Go (Улучшенная версия)

## Критические улучшения для работы с Oracle AQ

### Работа с Oracle AQ очередью - детали реализации

#### Подключение к очереди и вычитывание сообщений

**queue.go - Детальная реализация:**

1. **Структура для работы с очередью:**
   ```go
   type QueueReader struct {
       db *DB
       queueName string
       consumerName string
   }
   ```

2. **Метод `DequeueMany(ctx, count)` - детали:**
   - Использование временных пакетов Oracle для работы с OUT-параметрами
   - PL/SQL блок для выполнения `DBMS_AQ.DEQUEUE`:
     ```sql
     DECLARE
       dequeue_options DBMS_AQ.dequeue_options_t;
       message_properties DBMS_AQ.message_properties_t;
       message_handle RAW(16);
       message SYS.AQ$_JMS_TEXT_MESSAGE;
     BEGIN
       dequeue_options.consumer_name := 'SUB_EMAIL_SENDER';
       dequeue_options.wait := :wait_timeout;
       dequeue_options.navigation := DBMS_AQ.FIRST_MESSAGE;
       dequeue_options.dequeue_mode := DBMS_AQ.REMOVE;  -- КРИТИЧЕСКИ ВАЖНО!
       DBMS_AQ.DEQUEUE(
         queue_name => 'askaq.aq_ask',
         dequeue_options => dequeue_options,
         message_properties => message_properties,
         payload => message,
         msgid => message_handle
       );
       temp_pkg_queue.g_xml_data := XMLSerialize(CONTENT message.text_vc AS CLOB);
       temp_pkg_queue.g_message_id := message_handle;
     END;
     ```
   - Чтение результатов через временный пакет: `SELECT temp_pkg_queue.get_xml_data() FROM DUAL`
   - **Критически важно:** `DequeueMode = REMOVE` означает, что сообщение удаляется из очереди сразу после чтения
   - Первое сообщение читается с полным timeout (50ms), последующие - с минимальным (50ms)
   - Проверка контекста перед каждой итерацией: `if ctx.Err() != nil { return }`

3. **Транзакции при работе с очередью:**
   - Каждое сообщение вычитывается в **отдельной транзакции**
   - После успешного чтения сообщение **сразу удаляется** из очереди (REMOVE mode)
   - Если обработка сообщения не удалась - статус ошибки сохраняется в БД в **отдельной транзакции**
   - **Критически важно:** Сообщения уже вычитаны из очереди (REMOVE), поэтому ОБЯЗАНЫ быть обработаны до конца

#### Переподключение и атомарность транзакций

**oracle.go - Детальная реализация:**

1. **Структура для работы с БД:**
   ```go
   type DB struct {
       db *sql.DB
       mu sync.RWMutex  // Защита от параллельного переподключения
       activeTx int64    // Счетчик активных транзакций (atomic)
   }
   ```

2. **Методы для безопасного доступа:**
   - `WithDB(ctx, fn)` - для операций без транзакций (использует `RLock()`)
   - `WithDBTx(ctx, fn)` - для транзакций (использует `Lock()`, управляет счетчиком)
   - Все методы принимают `context.Context` для таймаутов и отмены

3. **Счетчик активных транзакций:**
   - Использование `atomic.AddInt64()` и `atomic.LoadInt64()` для атомарных операций
   - `BeginTx()` - увеличивает счетчик перед началом транзакции
   - `Commit()`/`Rollback()` - уменьшают счетчик после завершения транзакции
   - `Reconnect(ctx)` ждет завершения транзакций (до 35 секунд) перед переподключением

4. **Переподключение:**
   - Переподключение только при ошибках соединения (не периодическое)
   - Проверка активных транзакций перед переподключением через `atomic.LoadInt64()`
   - Метод `waitForActiveTransactions(ctx)` - ожидание завершения транзакций с таймаутом
   - При переподключении:
     1. Блокировка через `Lock()` для предотвращения новых транзакций
     2. Ожидание завершения активных транзакций (до 35 секунд)
     3. Закрытие старого соединения
     4. Создание нового соединения
     5. Разблокировка

5. **Атомарность транзакций при переподключении:**
   - Все транзакции должны завершиться (commit или rollback) перед переподключением
   - Если транзакция не завершилась за 35 секунд - логирование ошибки и принудительный откат
   - При переподключении во время транзакции - транзакция откатывается, операция повторяется после переподключения
   - **Критически важно:** Сообщения, уже вычитанные из очереди, обрабатываются до переподключения

#### Временные пакеты Oracle

**procedures.go - Детальная реализация:**

1. **Создание временных пакетов:**
   ```sql
   CREATE OR REPLACE PACKAGE temp_pkg_email AS
     FUNCTION get_result RETURN VARCHAR2;
     FUNCTION get_err_code RETURN NUMBER;
     FUNCTION get_err_desc RETURN VARCHAR2;
   END;
   
   CREATE OR REPLACE PACKAGE BODY temp_pkg_email AS
     g_result VARCHAR2(32767);
     g_err_code NUMBER;
     g_err_desc VARCHAR2(4000);
     
     FUNCTION get_result RETURN VARCHAR2 IS BEGIN RETURN g_result; END;
     FUNCTION get_err_code RETURN NUMBER IS BEGIN RETURN g_err_code; END;
     FUNCTION get_err_desc RETURN VARCHAR2 IS BEGIN RETURN g_err_desc; END;
   END;
   ```

2. **Использование временных пакетов:**
   - Вызов процедуры с сохранением результатов в пакетные переменные
   - Чтение результатов через функции-геттеры: `SELECT temp_pkg_email.get_result() FROM DUAL`
   - Все операции выполняются в транзакции через `WithDBTx()`

#### Graceful shutdown

**service.go - Детальная реализация:**

1. **Обработка сигналов:**
   - Обработка `os.Interrupt`, `syscall.SIGTERM`, `syscall.SIGINT` через `signal.Notify()`
   - Создание `shutdownCtx` с таймаутом (10 секунд по умолчанию)

2. **Завершение операций:**
   - Прекращение чтения новых сообщений из очереди
   - Обработка уже вычитанных сообщений продолжается до завершения
   - Использование `sync.WaitGroup` для отслеживания всех горутин
   - При отмене контекста - попытка сохранения через `context.Background()` для критических операций

3. **Критически важно:**
   - Сообщения уже вычитаны из очереди (REMOVE), поэтому ОБЯЗАНЫ быть обработаны до конца
   - При graceful shutdown - обработка уже вычитанных сообщений перед выходом
   - Использование `shutdownCtx` для проверки необходимости завершения

#### Обработка ошибок Oracle

1. **Проверка типов ошибок:**
   - Использование `errors.Is()` и `errors.As()` для проверки типов ошибок Oracle
   - Код 25228 - очередь пуста (не ошибка, возвращаем `nil`)
   - Код 25263 - критическая ошибка (требует рестарта сервиса)

2. **Логирование:**
   - Все ошибки логируются с контекстом (taskId, messageId и т.д.)
   - Использование структурированного логирования через zap

## Полная структура проекта

```
email-service/
├── cmd/
│   └── email-service/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── database/
│   │   ├── oracle.go
│   │   ├── queue.go
│   │   └── procedures.go
│   ├── email/
│   │   ├── smtp.go
│   │   ├── pop3.go
│   │   └── dsn.go
│   ├── parser/
│   │   └── xml.go
│   ├── logger/
│   │   └── logger.go
│   └── service/
│       └── service.go
├── pkg/
│   └── attachments/
│       ├── crystal.go
│       ├── clob.go
│       └── file.go
├── go.mod
├── go.sum
├── config.ini
└── README.md
```

## Основные компоненты

### Конфигурация (`internal/config/config.go`)

- Парсинг INI файла (использовать `gopkg.in/ini.v1` для совместимости с существующим форматом)
- Структуры для SMTP конфигурации (массив до 5 серверов)
- Параметры Oracle, расписания, режимов работы
- Валидация конфигурации при старте
- Использование `time.Duration` для всех временных интервалов
- Поддержка переменных окружения для переопределения (опционально)

### Работа с Oracle (`internal/database/`)

**oracle.go:**
- Использование `database/sql` с `github.com/godror/godror` драйвером
- **Connection Pooling:**
  - `MaxOpenConns=200` - максимальное количество открытых соединений
  - `MaxIdleConns=10` - максимальное количество idle соединений
  - `ConnMaxLifetime=5min` - максимальное время жизни соединения
  - `ConnMaxIdleTime=30min` - максимальное время idle соединения
- **Переподключение:**
  - Переподключение только при ошибках соединения (не периодическое)
  - Использование `sql.DB.Ping(ctx)` для проверки соединения
  - Автоматическое восстановление через retry с экспоненциальной задержкой
- **Таймауты:**
  - Использование `context.Context` для всех операций с таймаутами
  - `QueryTimeout=30s`, `ExecTimeout=30s`, `ConnectionTimeout=10s`
- **Безопасность:**
  - Все операции через методы с `context.Context`
  - Использование транзакций через `(*sql.DB).BeginTx(ctx, ...)`
  - Graceful shutdown через отмену контекста

**queue.go:**
- Детали реализации описаны выше в разделе "Работа с Oracle AQ очередью"

**procedures.go:**
- `GetTestEmail(ctx)` - получение тестового email через `pcsystem.PKG_EMAIL.GET_TEST_EMAIL()`
- `GetWebServiceUrl(ctx)` - адрес Crystal Reports через `pcsystem.PKG_EMAIL.GET_SOAP_ADDRESS()`
- `GetEmailReportClob(ctx, taskId, clobId)` - получение CLOB вложений через `pcsystem.pkg_email.get_email_report_clob()`
- `SaveEmailResponse(ctx, taskId, status, responseDate, errorText)` - вызов `pcsystem.pkg_email.save_email_response()`
- Все процедуры используют транзакции через `BeginTx()` с контекстом
- Использование временных пакетов Oracle для работы с OUT-параметрами (детали выше)

### Email клиенты (`internal/email/`)

**smtp.go:**
- Использовать `github.com/go-mail/mail/v3` (современная версия) или `github.com/emersion/go-smtp`
- Поддержка TLS/SSL (автоопределение как в MailKit через `tls.Config{ServerName: host}`)
- Реализация DSN через Envelope ID (`askemailsender{taskId}`)
- Ограничение частоты отправки (MinSendIntervalMsec, MinSendEmailIntervalMsec)
- Автоматическое переподключение при разрыве соединения
- Использование `context.Context` для таймаутов отправки
- Connection pooling для SMTP клиентов

**pop3.go:**
- Использовать `github.com/emersion/go-pop3`
- Периодическая проверка DSN (каждые 60 минут через `time.Ticker`)
- Парсинг статусов доставки
- Поддержка контекста для graceful shutdown

**dsn.go:**
- Парсинг DSN сообщений (RFC 3464)
- Использование `github.com/emersion/go-message` для парсинга
- Извлечение статусов: delivered, failed, delayed, relayed, expanded
- Сопоставление Envelope ID с taskId

### Парсер XML (`internal/parser/xml.go`)

- Использование `encoding/xml` из стандартной библиотеки
- Парсинг структуры сообщения из Oracle AQ
- Извлечение данных письма: taskId, smtpId, emailAddress, title, text, schedule
- Парсинг вложений (attach элементы)
- Обработка параметров вложений (attach_param)
- Валидация обязательных полей

### Обработка вложений (`pkg/attachments/`)

**crystal.go:**
- Интеграция с Crystal Reports Web Service (SOAP)
- Использование `net/http` с `context.Context`
- Парсинг SOAP через `encoding/xml`

**clob.go:**
- Загрузка и декодирование Base64 из CLOB
- Использование `encoding/base64` из стандартной библиотеки
- Потоковая обработка больших файлов

**file.go:**
- Чтение готовых файлов с диска
- Использование `os.Open()` с `context.Context`
- Валидация путей для безопасности

### Логирование (`internal/logger/logger.go`)

- Использование `go.uber.org/zap` для структурированного логирования
- Ротация логов через `gopkg.in/natefinch/lumberjack.v2`:
  - `MaxSize=100MB` - максимальный размер файла перед ротацией
  - `MaxBackups` - количество архивных файлов (из конфига)
  - `MaxAge=10` дней - хранение логов
  - `Compress=true` - сжатие архивных файлов
- Уровни логирования: Panic(0), Fatal(1), Error(2), Warn(3), Info(4), Debug(5)
- Двойной вывод: в файл (JSON) и консоль (читаемый формат через `zap.NewDevelopmentEncoderConfig()`)
- Структурированные логи с полями: `zap.Int64("taskID", ...)`, `zap.String("messageID", ...)`
- Поддержка `zap.AddCaller()` и `zap.AddStacktrace(zap.ErrorLevel)` для ошибок
- Использование `zap.S()` для глобального логгера

### Основной сервис (`internal/service/service.go`)

- Главный цикл обработки с использованием `context.Context`
- Очередь сообщений: использование `sync.Map` или `map[string]*Message` с `sync.RWMutex` для in-memory хранения
- Очередь результатов: использование `chan` для асинхронной записи в БД
- Обработка расписания отправки (TimeStart - TimeEnd) через `time.Time` сравнения
- Ограничение частоты отправки на email адрес через `map[string]time.Time` с очисткой устаревших записей
- Автоматический рестарт при критических ошибках (ORA-25263, SMTP "4.3.2 Please try again later")
- **Graceful shutdown:** (детали описаны выше)

## Особенности реализации

### Тестовый режим

- При `ModeDebug = true`:
  - Вызов `pcsystem.PKG_EMAIL.GET_TEST_EMAIL()` при каждой отправке (с кешированием на 5 минут)
  - Замена адреса получателя на тестовый
  - Логирование замены адреса с использованием `zap.String("original", ...)`, `zap.String("test", ...)`

### Обработка ошибок

- Использование `errors.Is()` и `errors.As()` для проверки типов ошибок Oracle
- Подсчет критических ошибок (ORA-25263, SMTP "4.3.2 Please try again later")
- Автоматический рестарт при превышении `MaxErrorCountForAutoRestart`
- Graceful shutdown с завершением текущих операций
- **Важно:** Сообщения уже вычитаны из очереди (REMOVE), поэтому ОБЯЗАНЫ быть обработаны до конца
- При отмене контекста - сохранение статуса через `context.Background()` для предотвращения потери данных
- Использование `fmt.Errorf()` с `%w` для оборачивания ошибок

### Производительность

- Пакетная обработка (portion = 20 сообщений за цикл, настраивается)
- Параллельная обработка вложений через `sync.WaitGroup` и горутины
- Неблокирующие операции с очередями через `select` с `default`
- Использование connection pooling для БД (не `RWMutex` для чтения - пул сам управляет соединениями)
- Батчинг операций записи в БД через канал с батчингом (до 10000 за цикл или по таймауту)
- Использование `sync.Pool` для переиспользования буферов при парсинге XML

### Безопасность работы с БД

- **Connection Pooling:**
  - Использование стандартного `database/sql` пула вместо ручного управления соединениями
  - Настройки пула через `SetMaxOpenConns()`, `SetMaxIdleConns()`, `SetConnMaxLifetime()`, `SetConnMaxIdleTime()`
  - Автоматическое управление соединениями драйвером
- **Транзакции:**
  - Все операции записи через `BeginTx(ctx, ...)` с контекстом
  - Использование `defer tx.Rollback()` для гарантированного отката при ошибках
  - Явный `tx.Commit()` только после успешного выполнения
- **Контекст:**
  - Все операции БД принимают `context.Context` для таймаутов и отмены
  - Использование `context.WithTimeout()` для операций с таймаутами
  - Graceful shutdown через отмену контекста

## Зависимости Go

```go
require (
    github.com/godror/godror v0.40.0          // Oracle driver
    github.com/go-mail/mail/v3 v3.3.1         // SMTP client (современная версия)
    github.com/emersion/go-pop3 v0.2.0        // POP3 client
    github.com/emersion/go-message v0.17.0    // Email parsing
    gopkg.in/ini.v1 v1.67.0                   // INI parser (для совместимости)
    go.uber.org/zap v1.26.0                   // Structured logging
    gopkg.in/natefinch/lumberjack.v2 v2.2.1   // Log rotation
)
```

## Конфигурационный файл (config.ini)

Структура аналогична текущему `email_sender.ini`:
- Секция `[ORACLE]` - подключение к БД
- Секции `[SMTP]`, `[SMTP1]` ... `[SMTP4]` - настройки SMTP серверов
- Секция `[Mode]` - режимы работы (Debug, SendHiddenCopyToSelf, IsBodyHTML)
- Секция `[Schedule]` - временные рамки отправки
- Секция `[Log]` - настройки логирования

## Этапы реализации

1. **Этап 1:** Базовая структура проекта, конфигурация, логирование
2. **Этап 2:** Подключение к Oracle с connection pooling и работа с AQ очередью
3. **Этап 3:** Парсинг XML сообщений и создание структур данных
4. **Этап 4:** Реализация SMTP клиента с DSN поддержкой
5. **Этап 5:** Обработка вложений (все три типа)
6. **Этап 6:** POP3 клиент для получения статусов доставки
7. **Этап 7:** Основной цикл обработки и интеграция компонентов
8. **Этап 8:** Тестовый режим и обработка ошибок
9. **Этап 9:** Graceful shutdown и тестирование
10. **Этап 10:** Оптимизация и документация

## Ключевые отличия от C# версии и улучшения

- Использование goroutines для параллельной обработки
- Context для управления жизненным циклом операций (вместо счетчика активных операций)
- Каналы (channels) для синхронизации вместо locks где возможно
- Стандартная библиотека `context` для таймаутов и отмены операций
- Структурированное логирование через zap
- **Connection pooling через `database/sql`** вместо ручного управления соединениями
- **Переподключение только при ошибках** вместо периодического переподключения
- Graceful shutdown с обработкой уже вычитанных сообщений
- Использование `errors.Is()` и `errors.As()` для проверки типов ошибок
- Использование `sync.Pool` для переиспользования ресурсов

## Паттерны из проекта smsSender

### Структура проекта
- Разделение по функциональности: `database/`, `email/`, `logger/`, `service/`
- Использование `internal/` для приватных модулей
- Использование `cmd/` для точки входа приложения

### Стиль кодинга
- Структурированное логирование с контекстом: `logger.Log.Info("message", zap.String("key", value))`
- Использование интерфейсов для гибкости и тестируемости
- Обработка ошибок с проверкой контекста: `if ctx.Err() == context.Canceled`
- Комментарии на русском языке для документации
- Использование `defer` для гарантированного освобождения ресурсов

### Работа с транзакциями
- Все операции записи в БД выполняются через транзакции с `BeginTx()`
- Использование временных пакетов Oracle для работы с OUT-параметрами
- PL/SQL блоки для вызова процедур с сохранением результатов в пакетные переменные
- Чтение результатов через функции-геттеры пакетов: `SELECT temp_pkg.get_result() FROM DUAL`

### Graceful shutdown
- Единый таймаут shutdown для всего приложения
- Использование `shutdownCtx` с таймаутом для завершения операций
- Обработка уже вычитанных сообщений даже при shutdown (критически важно!)
- Использование `sync.WaitGroup` для отслеживания всех горутин
- При отмене контекста - попытка сохранения через `context.Background()` для критических операций

### Работа с очередью Oracle AQ
- Использование `DequeueMany(ctx, count)` для батчевого чтения сообщений
- Первое сообщение читается с полным timeout, последующие - с минимальным (50ms)
- Проверка контекста перед каждой итерацией чтения
- При graceful shutdown - обработка уже вычитанных сообщений перед выходом
- Использование временных пакетов Oracle для работы с `DBMS_AQ.DEQUEUE`

### Обработка сообщений
- Батчевая обработка сообщений (по 10-100 штук)
- Параллельная обработка батчей через goroutines с `sync.WaitGroup`
- При ошибке обработки - сохранение статуса ошибки в БД
- При graceful shutdown - завершение обработки текущих батчей с использованием `shutdownCtx`

## Основные изменения в плане

1. **Убрано периодическое переподключение** - переподключение только при ошибках
2. **Добавлены детали о транзакциях** - каждая операция с очередью в отдельной транзакции
3. **Добавлены детали о временных пакетах Oracle** - примеры создания и использования
4. **Добавлены детали о graceful shutdown** - обработка уже вычитанных сообщений
5. **Добавлены детали о переподключении** - ожидание завершения транзакций перед переподключением
6. **Добавлены детали о PL/SQL блоках** - примеры работы с DBMS_AQ.DEQUEUE
7. **Использование atomic операций** для счетчика активных транзакций вместо обычных операций
8. **Улучшена структура работы с БД** - использование стандартного connection pooling вместо ручного управления

